---
title: "Feb9HW3"
format: html
---

```{r}
sessionInfo()
```

Load necessary libraries
```{r}
library(arrow)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```
Display your machine memory.
```{r}
memuse::Sys.meminfo()
```

In this exercise, we use tidyverse (ggplot2, dplyr, etc) to explore the MIMIC-IV data introduced in homework 1 and to build a cohort of ICU stays.

## Question 1: 

Q1. Visualizing patient trajectory
Visualizing a patient’s encounters in a health care system is a common task in clinical data analysis. In this question, we will visualize a patient’s ADT (admission-discharge-transfer) history and ICU vitals in the MIMIC-IV data.

## Question 1.1:

**Reading in the files for Q1**

```{r}
patients <- arrow::open_dataset("~/mimic/hosp/patients.csv.gz", format = "csv")

admissions <- arrow::open_dataset("~/mimic/hosp/admissions.csv.gz", format = "csv")

transfers <- arrow::open_dataset("~/mimic/hosp/transfers.csv.gz", format = "csv")

procedures_icd <- arrow::open_dataset("~/mimic/hosp/procedures_icd.csv.gz", format = "csv")

diagnoses_icd <- arrow::open_dataset("~/mimic/hosp/diagnoses_icd.csv.gz", format = "csv")

d_icd_procedures <- arrow::open_dataset("~/mimic/hosp/d_icd_procedures.csv.gz", format = "csv")

d_icd_diagnoses <- arrow::open_dataset("~/mimic/hosp/d_icd_diagnoses.csv.gz", format = "csv")

```


**First, I am going to designate the patient ID so that the TA can change it later and it can be easily filtered. Afterwards, I will then use the subject_id to filter the data sets**

```{r}
subject_id <- 10001217

patients.filter <- patients %>%
  collect() %>%
  dplyr::filter(subject_id == !!subject_id)

admissions.filter <- admissions %>%
  dplyr::filter(subject_id == !!subject_id)

transfers.filter <- transfers %>%
  dplyr::filter(subject_id == !!subject_id)

procedures_icd.filter <- procedures_icd %>%
  dplyr::filter(subject_id == !!subject_id)

diagnoses_icd.filter <- diagnoses_icd %>%
  dplyr::filter(subject_id == !!subject_id)

d_icd_procedures.filter <- d_icd_procedures %>%
  dplyr::filter(subject_id == !!subject_id)

d_icd_diagnoses.filter <- d_icd_diagnoses %>%
  dplyr::filter(subject_id == !!subject_id)
```

**Now, I want to make sure that this was correct by looking at the first ten lines of each the files**

**For Patients**
```{r}
patients10 <- patients.filter %>%
  head(10) %>%
  collect()

print(patients10)
```
**For Admissions**

```{r}
admissions10 <- admissions.filter %>%
  head(10) %>%
  collect()

print(admissions10)
```

**For Transfers**

```{r}
transfers10 <- transfers.filter %>%
  head(10) %>%
  collect()

print(transfers10)
```

**For Procedures_icd**

```{r}
procedures_icd10 <- procedures_icd.filter %>%
  head(10) %>%
  collect()

print(procedures_icd10)
```

**For Diagnoses_icd**

```{r}
diagnoses_icd10 <- diagnoses_icd.filter %>%
  head(10) %>%
  collect()

print(diagnoses_icd10)

```

**For d_icd_procedures**

```{r}
d_icd_procedures10 <- d_icd_procedures.filter %>%
  head(10) %>%
  collect()

print(d_icd_procedures10)
```

**For d_icd_diagnoses**

```{r}
d_icd_diagnoses10 <- d_icd_diagnoses.filter %>%
  head(10) %>%
  collect()

print(d_icd_diagnoses10)

```

**All of the code above addresses the other data sets in the mimic folder. However, we still have to look into the labevents folder as well**

**This is specifically for the labevents**

**The first goal, we want to see what parquet we want to use, using BASH, by looking at the first 10 lines**

```{bash}
zcat < ~/mimic/hosp/labevents_filtered.csv.gz | head -10
```

**Looking at this, this data is filtered for the adequate columns we need. However, we already created a parquet of the data as well. Let us see if we can look ten lines into the parquet to see which one we should use**

```{r}
file.info("part-0.parquet")$size
```
**This is 152 MB, so this is the parquet used in labevents.filtered folder in the hosp filter within the mimic folder**

```{r}

labevents_pq <- read_parquet("~/mimic/hosp/part-0.parquet")

labevents_pq10 <- labevents_pq %>%
  head(10) %>%
  collect()

print(labevents_pq10)
```

**Now, let us filter the parquet to go with what we are looking for: subject ID 10001217**

```{r}
labevents_pq.filter <- labevents_pq %>%
  dplyr::filter(subject_id == !!subject_id)
```

**Now, let us look at the first ten lines of the filtered parquet**

```{r}
labevents_pq10.filter <- labevents_pq.filter %>%
  head(10) %>%
  collect()

print(labevents_pq10.filter)
```

With this in mind, we now want to create a symbolic link to the parquet we created in HW2, part.0.parquet, so that we can use it in this homework.

**When I do this command, it says that the symbolic link file already exists. SO let us check to see if one already exists**

```{bash}
ls -l ~/mimic/hosp/part-0.parquet
```
**as we can see here, it does**

**Now, we have to conjoin the necessary tables for the data**

**Since we have the dictionary for the diagnoses and the diagnoses themselves, we can merge them together to figure out what actually happened**

```{r}
LJDiagnoses <- diagnoses_icd.filter %>%
  left_join(d_icd_diagnoses.filter, by = c("icd_code", "icd_version"))

LJDiagnoses10 <- LJDiagnoses %>%
  head(10) %>%
  collect()

print(LJDiagnoses10)

```
**The top diagnoses were intestinal adhesions with obstruction, acurate respiratory failure with hypoxia, and von willebrand disease. We have to make sure we count each of the different long_titles and ensure they are able to put into the ggplot. I received an error regarding an as_vector, so let us set this to true to prevent this happening as well.**

```{r}
LJDiagnosesT3 <- LJDiagnoses %>%
  count(long_title, sort=TRUE) %>%
  head(3) %>%
  pull(long_title, as_vector = TRUE)
```

**Let us now left join the procedures based on the ICD_Code and ICD_version**

```{r}
LJProcedures <- procedures_icd.filter %>%
  left_join(d_icd_procedures, by = c("icd_code", "icd_version"))

LJProcedures10 <- LJProcedures %>%
  head(10) %>%
  collect()

print(LJProcedures10)

```

**I received an error prior about how this data is not a data.frame. Let us convert these to a data frame to prevent this from happening**

**Created data.frame so that we can use it in ggplot**
```{r}
transfer.filter2 <- as.data.frame(transfers.filter)
LJProcedures <- as.data.frame(LJProcedures)
```

**Changing it so that GGplot can read date and time better**
```{r}
transfer.filter2 <- transfer.filter2 %>%
  mutate(intime = as.POSIXct(intime, format="%Y-%m-%d %H:%M:%S"),
         outtime = as.POSIXct(outtime, format="%Y-%m-%d %H:%M:%S"))

LJProcedures <- LJProcedures %>%
  mutate(chartdate = as.POSIXct(chartdate, format="%Y-%m-%d"))

labevents.filter <- labevents_pq.filter %>%
  collect() %>%
  mutate(charttime = as.POSIXct(charttime, format="%Y-%m-%d %H:%M:%S"))
```

**We have to make sure we get the title of the graph as well**

**Let us get the patient's info**

```{r}
patient_info <- paste0(
  "Patient ", subject_id, ", ", 
  patients.filter$gender, ",", 
  patients.filter$anchor_age, " years old"
)

print(patient_info)
```

**When we do the regular ggplot, the legend has text that is way too long. Let us wrap this**

**Now let us make each procedure a unique factor so that it can be recognized in ggplot**

```{r}
library(stringr)

# Apply str_wrap() to wrap text for better legend display
LJProcedures$long_title_wrapped <- str_wrap(LJProcedures$long_title, 
                                            width = 17)

# Check result
print(LJProcedures)

```
**Now let us make each procedure a unique factor so that it can be recognized in ggplot**

```{r}
ProceduresUnique <- unique(LJProcedures$long_title_wrapped)
Shapemanual <- setNames(seq_along(ProceduresUnique) %% 
                          5 +20, ProceduresUnique)
Colormanual <- setNames(seq_along(transfer.filter2$careunit) %% 
                          25 +1, transfer.filter2$careunit)
```


**Now, let us make the ggplot**

```{r}
ggplot() +
 # Procedures (Different Shapes)
  geom_point(data = LJProcedures,  
             aes(x = chartdate, y = "Procedure", shape = 	
long_title_wrapped),  
             color = "black",   
             size = 4,  
             alpha = 0.7) +  
  
  # ADT Events (Colored by Care Unit)
  geom_segment(data = transfer.filter2, 
               aes(x = intime, xend = outtime, y = "ADT",  
                   color = careunit), 
               size = 4)  +

  # Lab Events (Black crosses `+`)
  geom_point(data = labevents.filter, 
             aes(x = charttime, y = "Lab"),
             shape = 3, size = 3, color = "black") +



  # Labels (Fixed title variable)
  labs(
    y = "", 
    x = "Calendar Time", 
    title = patient_info,  # Corrected variable usage
    subtitle = paste0("Top 3 Diagnoses:\n", 
                      paste(LJDiagnosesT3, collapse = "\n")),
    color = "Care Unit",
    shape = "Procedure"
  ) +  # Guides for Legend Formatting
guides(
    color = guide_legend(title = "Care Unit", nrow = 2, 
                         title.position = "top"),  
    shape = guide_legend(title = "Procedure", nrow = 1, 
                         title.position = "top"),
    override.aes = list(size=3))+
  
   # Care Unit Colors
 scale_color_manual(values = Colormanual) +
  # Procedure Shapes
  scale_shape_manual(values = Shapemanual) +
  scale_y_discrete(limits = rev) +

  # Theme Fixes to Ensure Plot is Visible
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.text.x = element_text(angle = 0, hjust = 1),
    legend.position = "bottom",  # Ensures legend is below
    legend.box = "vertical",  # Places legends in a single row
    legend.key.size = unit(1, "cm"),  # Adjusts legend item size
    legend.text = element_text(size = 7.5),
    plot.margin = margin(5, 5, 5, 5),
    legend.spacing.y = unit(0.01, "cm"),
    legend.box.spacing = unit(0.01, "cm")
  )
```


## 1.2 Question 

**First, let us make sure that the chartevents.csv is read into the system and confirm that we have the right directory for it**

```{bash}

#| eval: false

zcat < ~/mimic/icu/chartevents.csv.gz > ~/mimic/icu/chartevents.csv

```

```{bash}

ls -l ~/mimic/icu/chartevents.csv
```

**We can now open the data set**

```{r}
chartevents.arrow <- arrow::open_dataset("~/mimic/icu/chartevents.csv", 
                                         format = "csv")
```

**And filter it based on the information we would like: 220045, 220181, 220179, 223761, and 22010**

```{r}
library(dplyr
        )
chartevents.filtered.arrow <- chartevents.arrow %>%
  dplyr::select(subject_id, itemid, charttime, valuenum) %>%
  dplyr::filter(itemid %in% c(220045, 220181, 220179, 223761, 220210)) %>%
  dplyr::filter(subject_id == !!subject_id)
  
```

**Let us make sure that everything looks correct**

```{r}
charteventsprint <- chartevents.filtered.arrow %>%
head(50) %>%
collect()

print(charteventsprint)
```

**Like before, we need to make sure that we make the data frame so that ggplot can read it and that the dates and time are consistent**

```{r}
chartevents.filtered.arrow <- as.data.frame(chartevents.filtered.arrow)
chartevents.filtered.arrow$charttime <- as.POSIXct(
  chartevents.filtered.arrow$charttime, format="%Y-%m-%d %H:%M:%S")
```

**Received an error saying that the values are not a factor. So let us make it one**

```{r}
chartevents.filtered.arrow$subject_id <- as.factor(
  chartevents.filtered.arrow$subject_id)
```

**Let us make sure that the above command worked**

```{r}
colnames(chartevents.filtered.arrow)
```

**Reading in the ICUStays and then filtering it for the ID given**

```{bash}

zcat < ~/mimic/icu/icustays.csv.gz > ~/mimic/icu/icustays.csv

```

```{r}

icustays <- arrow::open_dataset("~/mimic/icu/icustays.csv", format = "csv")

```

**I want to make sure that all the data sets are read in correctly after filtering**

**We can now do the same thing but this time filter the icustays with the correct subject_id**

```{r}
icustays.filtered <- icustays %>%
  collect() %>%
  dplyr::filter(subject_id == !!subject_id)
```

**Now we have to ensure that both of the factors are the same so that they can be graphed**

```{r}
icustays.filtered10 <- icustays.filtered %>%
  head(10) %>%
  collect()

print(icustays.filtered10)
```
```{r}

chartevents.filtered.arrow$subject_id <- as.integer(
  as.character(chartevents.filtered.arrow$subject_id))

icustays.filtered$subject_id <- as.integer(
  icustays.filtered$subject_id)

```

**To make it universal, we will have to figure out what the minimum and maximum charttimes are for both the stay_ids. We do the as.POSIXct as that is the error I got that I needed to fix**
```{r}
min_datetime1 <- as.POSIXct(icustays.filtered$intime[1])
max_datetime1 <- as.POSIXct(icustays.filtered$outtime[1])

min_datetime2 <- as.POSIXct(icustays.filtered$intime[2])
max_datetime2 <- as.POSIXct(icustays.filtered$outtime[2])

min_datetime1
max_datetime1 
min_datetime2
max_datetime2
```

**We are making it so that if the time falls between min and max 1, it is assigned the first stay_id. If it falls between min 2 and max 2, then it is assigned the second**

```{r}

chartevents.filtered.arrow <- chartevents.filtered.arrow %>%
  mutate(stay_id = case_when(
    charttime >= min_datetime1 & 
      charttime <= max_datetime1 ~ icustays.filtered$stay_id[1],
    charttime >= min_datetime2 & 
      charttime <= max_datetime2 ~ icustays.filtered$stay_id[2],
    TRUE ~ NA_real_  # Assign NA if charttime does not fit either stay
  ))

chartevents.filtered.arrow10 <- chartevents.filtered.arrow %>%
  head(10) %>%
  collect()

print(chartevents.filtered.arrow10)
```
```{r}
stay_ranges <- chartevents.filtered.arrow %>%
  group_by(stay_id) %>%
  summarise(min_time = min(charttime), max_time = max(charttime)) %>%
  ungroup()

# Use `scale_x_datetime()` but set the full range to include all timepoints
full_min_time <- min(stay_ranges$min_time)
full_max_time <- max(stay_ranges$max_time)
```

**With all the data in one table, we can not make the ggplot**

```{r}
ggplot(chartevents.filtered.arrow, 
       aes(x = charttime, y = valuenum, color = factor(itemid))) +
  geom_line(size = 0.8) + 
  geom_point(size = 1.5) + 
  facet_grid(itemid ~ stay_id, scales = "free", space = "fixed", 
             labeller = labeller(itemid = c(
    "220045" = "HR",
    "220181" = "NBPd",
    "220179" = "NBPs",
    "220210" = "RR",
    "223761" = "Temperature"
  ))) + 
  labs(
    title = paste("Patient", unique(chartevents.filtered.arrow$subject_id), 
                  "ICU stays - Vitals"),
    x = "",
    y = "",
    color = "Vital Type"
  ) +
  scale_x_datetime(date_labels = "%b %d %H:%M", date_breaks = "6 hours") +  
  theme_minimal() +
  theme(
    strip.text.x = element_text(size = 14, face = "bold", color = "white"),
    strip.text.y = element_text(size = 12, face = "bold"),
    strip.background = element_rect(fill = "grey80"),
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10),
    panel.border = element_rect(color = "grey50", fill = NA, linewidth = 1.5)
  )
```

## Q2. ICU stays
icustays.csv.gz (https://mimic.mit.edu/docs/iv/modules/icu/icustays/) contains data about Intensive Care Units (ICU) stays. The first 10 lines are

```{bash}
zcat < ~/mimic/icu/icustays.csv.gz | head
```

## Q2.1 Ingestion

Import icustays.csv.gz as a tibble icustays_tble.

```{r}
icustays_arrow <- arrow::open_dataset("~/mimic/icu/icustays.csv", 
                                      format = "csv")

icustays_tble <- icustays_arrow %>%
  collect() %>%  # Pulls data into memory
  as_tibble()

glimpse(icustays_tble)
```

## Q2.2 Summary and visualization
How many unique subject_id? Can a subject_id have multiple ICU stays? Summarize the number of ICU stays per subject_id by graphs.

**first let us find out how many unique subject_id there are**

```{r}

uniqueicu <- icustays_tble %>%
  distinct(subject_id) %>%
  nrow()

print(uniqueicu)
```

**So there are 65366 unique subject_ids** 

**Now let us check to see if a subject_id have multile stays in the intensive care unit**

```{r}
icustayscount <- icustays_tble %>%
  group_by(subject_id) %>%
  summarise(n = n()) %>%
  ungroup()

maxstays <- max(icustayscount$n)
print(maxstays)
```

**the answer is 41, so some subjects DO have multiple stays in the intensive care unit**

**We can make a histogram to illustrate the amount of icu stays per subject**

```{r}

ggplot(icustayscount, aes(x = icustayscount$n)) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Distribution of ICU Stays per Subject",
    x = "Number of ICU Stays",
    y = "Number of Patients"
  ) +
  coord_cartesian(xlim = c(1, 10)) +  # Adjust range as needed
  theme_minimal()

```
**This shows that the frequency of subjects only have one stay in the intensive care unit**


## Q3

Q3. admissions data

Information of the patients admitted into hospital is available in admissions.csv.gz. See https://mimic.mit.edu/docs/iv/modules/hosp/admissions/ for details of each field in this file. The first 10 lines are

```{bash}
zcat < ~/mimic/hosp/admissions.csv.gz | head
```

## Q3.1 Ingestion

Import admissions.csv.gz as a tibble admissions_tble.

```{r}
admissions_tble <- admissions %>%
  collect() %>%  # Pulls data into memory
  as_tibble()

glimpse(admissions_tble)
```

## Q3.2 Summary and visualization

Summarize the following information by graphics and explain any patterns you see.

number of admissions per patient
admission hour (anything unusual?)
admission minute (anything unusual?)
length of hospital stay (from admission to discharge) (anything unusual?)

**let us start by making a graph of the number of admissions per patient**

```{r}
admissionscount <- admissions_tble %>%
  group_by(subject_id) %>%
  summarise(n = n()) %>%
  ungroup()

ggplot(admissionscount, aes(x = admissionscount$n)) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Distribution of Admissions per Subject",
    x = "Number of Admissions",
    y = "Number of Patients"
  ) +
  coord_cartesian(xlim = c(1, 25)) +  # Adjust range as needed
  theme_minimal()

```
**Now let us make a graph summarizing the admission hour (anything unusual?)**

```{r}
ggplot(admissions_tble, aes(x = hour(admittime))) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Distribution of Admission Hour",
    x = "Hour",
    y = "Number of Admissions"
  ) +
  theme_minimal()
```
**What is interesting about this graph is that most of the admissions occur at the 12th hour, which is noon. This is interesting as most people would think that admissions would occur in the morning, but this is not the case. On top of this, the admissions in the 23rd and 0th hour are pretty high compared to their neighboring hours. This would make sense since some illnesses, like asthma, a disease that I suffer from, are more likely to get worse at night. Individuals may also try and manage their symptoms throughout the day, until they realize they actually cannot, which they would make this decision before going to bed (11 pm to 12 am)**

**Now let us make a graph summarizing the admission minute (anything unusual?)**

```{r}
ggplot(admissions_tble, aes(x = minute(admittime))) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Distribution of Admission Minute",
    x = "Minute",
    y = "Number of Admissions"
  ) +
  theme_minimal()
```
**What is unusual about this is that most of the admissions occurred at each quarter of an hour (0 minutes, 15 minutes, 30 minutes, and 45 minutes). On top of this minute 60 has no admissions in them, which would make sense as when minute sixty hits, it is minute zero of the new hour.**

**Now let us make a graph summarizing the length of hospital stay (from admission to discharge) (anything unusual?)**

```{r}
admissions_tble <- admissions_tble %>%
  mutate(admittime = as.POSIXct(admittime, format="%Y-%m-%d %H:%M:%S"),
         dischtime = as.POSIXct(dischtime, format="%Y-%m-%d %H:%M:%S"))

admissions_tble <- admissions_tble %>%
  mutate(length_of_stay = difftime(dischtime, admittime, units = "days"))

ggplot(admissions_tble, aes(x = length_of_stay)) +
  geom_histogram(fill = "steelblue", bins = 50) +
  labs(
    title = "Distribution of Length of Stay",
    x = "Length of Stay (Days)",
    y = "Number of Admissions"
  ) +
  coord_cartesian(xlim = c(1, 100))+
  theme_minimal()
```

## Q4.1 Ingestion
Import patients.csv.gz (https://mimic.mit.edu/docs/iv/modules/hosp/patients/) as a tibble patients_tble.

```{r}
patients_tble <- patients %>%
  collect() %>%  # Pulls data into memory
  as_tibble()

glimpse(patients_tble)
```
## Q4.2 Summary and visualization

Summarize variables gender and anchor_age by graphics, and explain any patterns you see.

**Let us start by making a graph of of the variable gender first**

**We have to make gender a factor since I get an error when I read it into ggplot**
```{r}
patients_tble <- patients_tble %>%
  mutate(gender = as.factor(gender))
```

**this will be making the graph**
```{r}
ggplot(patients_tble, aes(x = gender)) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Distribution of Patients by Gender",
    x = "Gender",
    y = "Number of Patients"
  ) +
  theme_minimal()
```
**It looks like most of the patients that show up identify as female for their gender. This makes sense considering that women have to go more to the doctors to check up on reproductive health and yearly screenings for cancer depending on their age**

**Now we have to do it by age**

```{r}
ggplot(patients_tble, aes(x = anchor_age)) +
  geom_histogram(fill = "steelblue", bins = 50) +
  labs(
    title = "Distribution of Patients by Age",
    x = "Age",
    y = "Number of Patients"
  ) +
  coord_cartesian(xlim = c(0, 100))+
  theme_minimal()
```
**This data is indicative age-rounding, where either the patient or the practitioner rounds the age of the patient either up or down. There is also no data before about 20 years of age, and past 87.5 years of age. As we know, these ages or possible so these are not being reported**

## Q5

labevents.csv.gz (https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) contains all laboratory measurements for patients. The first 10 lines are

```{bash}

zcat < ~/mimic/hosp/labevents.csv.gz | head


```

d_labitems.csv.gz (https://mimic.mit.edu/docs/iv/modules/hosp/d_labitems/) is the dictionary of lab measurements.

```{bash}
zcat < ~/mimic/hosp/d_labitems.csv.gz | head
```
We are interested in the lab measurements of creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931). Retrieve a subset of labevents.csv.gz that only containing these items for the patients in icustays_tble. Further restrict to the last available measurement (by storetime) before the ICU stay. The final labevents_tble should have one row per ICU stay and columns for each lab measurement.

**First, let us create the labevents file**

```{r}
labevents <- arrow::open_dataset("~/mimic/hosp/labevents.csv", format = "csv")
```

**Now let us make it a parquet so we can make the directory after**

```{r}
#| eval: false
arrow::write_dataset(labevents, path = "~/mimic/hosp/labevents_pq", format = "parquet")
```

**Now I have to make a symbolic link to the labevents_pq**

```{bash}

ls -l labevents_pq

```

```{r}
labevents_pq <- arrow::open_dataset("~/mimic/hosp/labevents_pq", format = "parquet")
```  

**Now let us filter for what we need and check to see if we did is correct**

```{r}
labevents_pq.filtered <- labevents_pq %>%
  dplyr::select(subject_id, storetime, itemid, charttime, valuenum) %>%
  dplyr::filter(itemid %in% c(50912, 50971, 50983, 50902, 50882, 51221, 51301, 50931))

labevents_pq.filtered10 <- labevents_pq.filtered %>%
  head(10) %>%
  collect()

print(labevents_pq.filtered10)

```

**Now we have to change the subject_id to an integer so that we can join it with the icustays_tble**

```{r}
icustays_tble <- icustays_tble %>%
  mutate(subject_id = as.integer(subject_id))

icustays_tble10 <- icustays_tble %>%
  head(10) %>%
  collect()

print(icustays_tble10)

```

**We now have to load the data into R and the do an inner_join. Note that an inner_join was used because a left_join took about 30 minutes to do**

```{r}

labevents_pq.filtered.icu <- labevents_pq.filtered %>%
  collect() %>%
  left_join(icustays_tble, by = c("subject_id"))

```

**Let us view the table to see if we are all set so far**

```{r}
labevents_pq.filtered.icu10 <- labevents_pq.filtered.icu %>%
  head(10) %>%
  collect()

print(labevents_pq.filtered.icu10)

```

**We need to filter it for the charttime less than the intime and then group it by the three important variables: subject_id, stay_id, and itemid. We then have to slice it per the instructions of Dr. Zhou in the slack and from what we saw in class, and then ungroup it after**

```{r}
labevents_pq.filtered.icu <- labevents_pq.filtered.icu %>%
  filter(storetime < intime) %>%
  group_by(subject_id, stay_id, itemid) %>%
  slice_max(order_by = storetime, n = 1) %>% 
  ungroup()
```

**Making the column names wide version**

```{r}
labevents_tble <- labevents_pq.filtered.icu %>%
  select(subject_id, stay_id, itemid, valuenum) %>%
  pivot_wider(names_from = itemid, values_from = valuenum)

labevents_tble
```

**Turn the data into the correct format**

```{r}

labevents_tble <- labevents_tble %>%
  mutate(across(where(is.list), ~ map_dbl(.x, ~ ifelse(is.null(.x), NA, .x))))
```

**renaming the variables**

```{r}
column_names <- c(
  "50882" = "Bicarbonate",
  "50902" = "Chloride",
  "50912" = "Creatinine",
  "50931" = "Glucose",
  "50971" = "Potassium",
  "50983" = "Sodium",
  "51221" = "Hematocrit",
  "51301" = "WBC"
)

```

```{r}
labevents_tble <- labevents_tble %>%
  rename_with(~ column_names[.x], .cols = names(column_names))
```

**Viewing the table**

```{r}
labevents_tble
```


## Q6

chartevents.csv.gz (https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The itemid variable indicates a single measurement type in the database. The value variable is the value measured for itemid. The first 10 lines of chartevents.csv.gz are

**Looking at the first few lines of the chartevents.csv.gz**

```{bash}

zcat < ~/mimic/icu/chartevents.csv.gz | head

```
d_items.csv.gz (https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the itemid in chartevents.csv.gz.

**Looking into the first few lines of the d_items.csv.gz file**

```{bash}

zcat < ~/mimic/icu/d_items.csv.gz | head

```

We are interested in the vitals for ICU patients: heart rate (220045), systolic non-invasive blood pressure (220179), diastolic non-invasive blood pressure (220180), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of chartevents.csv.gz only containing these items for the patients in icustays_tble. Further restrict to the first vital measurement within the ICU stay. The final chartevents_tble should have one row per ICU stay and columns for each vital measurement.

**Let us create the chartevents file, write it as a parquet, and then create a symbolic link to it**

```{r}

chartevents6 <- arrow::open_dataset("~/mimic/icu/chartevents.csv", format = "csv")

```

```{r}
#| eval: false

arrow::write_dataset(chartevents6, path = "~/mimic/hosp/chartevents_pq", format = "parquet")

```

**Now I have to make a symbolic link to the chartevents_pq**

```{bash}
#| eval: false

ln -s ~/mimic/hosp/chartevents_pq/part-0.parquet chartevents_pq

```

**Now I have to make sure that it exists**

```{bash}

ls -l chartevents_pq

```

**Turning chartevents into a parquet**

```{r}

chartevents6 <- arrow::open_dataset("~/mimic/hosp/chartevents_pq", format = "parquet")

```

**Now, let us filter for the required itemid values and then display the first ten lines of the needed tables**

```{r}
chartevents_filtered <- chartevents6 %>%
  dplyr::select(subject_id, itemid, charttime, valuenum, stay_id, storetime) %>%
  dplyr::filter(itemid %in% c(220045, 220179, 220180, 223761, 220210))

chartevents_filtered10 <- chartevents_filtered %>%
  head(10) %>%
  collect()

print(chartevents_filtered10)

icustays_tble10 <- icustays_tble %>%
  head(10) %>%
  collect()

print(icustays_tble10)

```
**Make the subject_ids in the icustays_tble into an integer as I did in Q5 and then make sure it worked**

```{r}
icustays_tble <- icustays_tble %>%
  mutate(subject_id = as.integer(subject_id))

icustays_tble10 <- icustays_tble %>%
  head(10) %>%
  collect()

print(icustays_tble10)
```
**Conduct an inner_join of the values from the "subject_id", "stay_id", and the "hadm_id". Hadm_id was used to avoid two **

```{r}
chartevents_icu <- chartevents_filtered %>%
  collect() %>%
  left_join(icustays_tble, by = c("subject_id", "stay_id"))
```

**View the data table created**

```{r}
chartevents_icu

```

**We need to arrange the values, then group them, and then get the first vital measurement (by storetime) within the ICU stay.**
```{r}
chartevents_icu_first <- chartevents_icu %>%
  arrange(subject_id, stay_id, itemid, storetime) 

chartevents_icu_second <- chartevents_icu_first %>%
  group_by(subject_id, stay_id, itemid, storetime) %>%
  summarise(valuenum = mean(valuenum, na.rm = TRUE), .groups = "drop") %>%  
  group_by(subject_id, stay_id, itemid) %>% 
  slice(1) %>%  
  ungroup()

chartevents_icu_second
  
```

```{r}
chartevents_pivot <- chartevents_icu_second %>%
  select(subject_id, stay_id, itemid, valuenum) %>%
  pivot_wider(names_from = itemid, values_from = valuenum)

chartevents_pivot

```
**Changing the column names to be more exact**

```{r}
chartevents_pivot <- chartevents_pivot %>%
  rename(
    Heart_Rate = "220045",
    SysBP = "220179",
    DiaBP = "220180",
    Temp = "223761",
    Respiratory_Rate = "220210"
  )

chartevents_pivot
```

##Q7

**Everything is read in. We now have to make the table**

```{r}

icu_adults <- icustays_tble %>%
  inner_join(admissions_tble, by = c("subject_id", "hadm_id")) %>%
  inner_join(patients_tble, by = "subject_id") %>%
  filter(anchor_age >= 18)  # Use anchor_age instead of calculating from dob

names(icu_adults)

```

**We have successfully merge it with admissions_tble, patients_tble, but now we need to do so by labevents_tble and chartevents_pivot**

```{r}

labevents_tble <- labevents_tble %>%
  select(subject_id, stay_id, Creatinine, Potassium, Sodium, Chloride, Bicarbonate, Hematocrit, WBC, Glucose)

glimpse(labevents_tble)

```

```{r}
  
chartevents_pivot <- chartevents_pivot %>%
  select(subject_id, stay_id, Heart_Rate, SysBP, DiaBP, Respiratory_Rate, Temp)

glimpse(chartevents_pivot)

```

**Now that we have modified the tables, we need to merge them**

```{r}

mimic_icu_cohort <- icu_adults %>%
  left_join(labevents_tble, by = c("subject_id", "stay_id")) %>%
  left_join(chartevents_pivot, by = c("subject_id", "stay_id"))

print(mimic_icu_cohort)

```
**This is the table as seen in the diagram**
