---
title: "Feb9HW3"
format: html
---

```{r}
sessionInfo()
```

Load necessary libraries
```{r}
library(arrow)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```
Display your machine memory.
```{r}
memuse::Sys.meminfo()
```

In this exercise, we use tidyverse (ggplot2, dplyr, etc) to explore the MIMIC-IV data introduced in homework 1 and to build a cohort of ICU stays.

##Question 1: --- 

Q1. Visualizing patient trajectory
Visualizing a patient’s encounters in a health care system is a common task in clinical data analysis. In this question, we will visualize a patient’s ADT (admission-discharge-transfer) history and ICU vitals in the MIMIC-IV data.

##Question 1.1: ---

Q1.1 ADT history
A patient’s ADT history records the time of admission, discharge, and transfer in the hospital. This figure shows the ADT history of the patient with subject_id 10001217 in the MIMIC-IV data. The x-axis is the calendar time, and the y-axis is the type of event (ADT, lab, procedure). The color of the line segment represents the care unit. The size of the line segment represents whether the care unit is an ICU/CCU. The crosses represent lab events, and the shape of the dots represents the type of procedure. The title of the figure shows the patient’s demographic information and the subtitle shows top 3 diagnoses.

 Do a similar visualization for the patient with subject_id 10063848 using ggplot.

Hint: We need to pull information from data files patients.csv.gz, admissions.csv.gz, transfers.csv.gz, labevents.csv.gz, procedures_icd.csv.gz, diagnoses_icd.csv.gz, d_icd_procedures.csv.gz, and d_icd_diagnoses.csv.gz. For the big file labevents.csv.gz, use the Parquet format you generated in Homework 2. For reproducibility, make the Parquet folder labevents_pq available at the current working directory hw3, for example, by a symbolic link. Make your code reproducible.

**Reading in the files for Q1**

```{r}
patients <- arrow::open_dataset("~/mimic/hosp/patients.csv.gz", format = "csv")

admissions <- arrow::open_dataset("~/mimic/hosp/admissions.csv.gz", format = "csv")

transfers <- arrow::open_dataset("~/mimic/hosp/transfers.csv.gz", format = "csv")

procedures_icd <- arrow::open_dataset("~/mimic/hosp/procedures_icd.csv.gz", format = "csv")

diagnoses_icd <- arrow::open_dataset("~/mimic/hosp/diagnoses_icd.csv.gz", format = "csv")

d_icd_procedures <- arrow::open_dataset("~/mimic/hosp/d_icd_procedures.csv.gz", format = "csv")

d_icd_diagnoses <- arrow::open_dataset("~/mimic/hosp/d_icd_diagnoses.csv.gz", format = "csv")

```

**I want to make sure that all the data sets are read in correctly after filtering**

**First, I am going to designate the patient ID so that the TA can change it later and it can be easily filtered. Afterwards, I will then use the subject_id to filter the data sets**

```{r}
subject_id <- 10063848

patients.filter <- patients %>%
  collect() %>%
  dplyr::filter(subject_id == !!subject_id)

admissions.filter <- admissions %>%
  dplyr::filter(subject_id == !!subject_id)

transfers.filter <- transfers %>%
  dplyr::filter(subject_id == !!subject_id)

procedures_icd.filter <- procedures_icd %>%
  dplyr::filter(subject_id == !!subject_id)

diagnoses_icd.filter <- diagnoses_icd %>%
  dplyr::filter(subject_id == !!subject_id)

d_icd_procedures.filter <- d_icd_procedures %>%
  dplyr::filter(subject_id == !!subject_id)

d_icd_diagnoses.filter <- d_icd_diagnoses %>%
  dplyr::filter(subject_id == !!subject_id)
```

**Now, I want to make sure that this was correct by looking at the first ten lines of each the files**

**For Patients**
```{r}
patients10 <- patients.filter %>%
  head(10) %>%
  collect()

print(patients10)
```
**For Admissions**

```{r}
admissions10 <- admissions.filter %>%
  head(10) %>%
  collect()

print(admissions10)
```

**For Transfers**

```{r}
transfers10 <- transfers.filter %>%
  head(10) %>%
  collect()

print(transfers10)
```

**For Procedures_icd**

```{r}
procedures_icd10 <- procedures_icd.filter %>%
  head(10) %>%
  collect()

print(procedures_icd10)
```

**For Diagnoses_icd**

```{r}
diagnoses_icd10 <- diagnoses_icd.filter %>%
  head(10) %>%
  collect()

print(diagnoses_icd10)

```

**For d_icd_procedures**

```{r}
d_icd_procedures10 <- d_icd_procedures.filter %>%
  head(10) %>%
  collect()

print(d_icd_procedures10)
```

**For d_icd_diagnoses**

```{r}
d_icd_diagnoses10 <- d_icd_diagnoses.filter %>%
  head(10) %>%
  collect()

print(d_icd_diagnoses10)

```

**All of the code above addresses the other data sets in the mimic folder. However, we still have to look into the labevents folder as well**

**This is specifically for the labevents**

**The first goal, we want to see what parquet we want to use, using BASH, by looking at the first 10 lines**

```{bash}
zcat < ~/mimic/hosp/labevents_filtered.csv.gz | head -10
```

**Looking at this, this data is filtered for the adequate columns we need. However, we already created a parquet of the data as well. Let us see if we can look ten lines into the parquet to see which one we should use**

```{r}
file.info("part-0.parquet")$size
```
**This is 152 MB, so this is the parquet used in labevents.filtered folder in the hosp filter within the mimic folder**

```{r}

labevents_pq <- read_parquet("~/mimic/hosp/part-0.parquet")

labevents_pq10 <- labevents_pq %>%
  head(10) %>%
  collect()

print(labevents_pq10)
```

**Now, let us filter the parquet to go with what we are looking for: subject ID 10001217**

```{r}
labevents_pq.filter <- labevents_pq %>%
  dplyr::filter(subject_id == !!subject_id)
```

**Now, let us look at the first ten lines of the filtered parquet**

```{r}
labevents_pq10.filter <- labevents_pq.filter %>%
  head(10) %>%
  collect()

print(labevents_pq10.filter)
```

With this in mind, we now want to create a symbolic link to the parquet we created in HW2, part.0.parquet, so that we can use it in this homework.

**When I do this command, it says that the symbolic link file already exists. SO let us check to see if one already exists**

```{bash}
ls -l ~/mimic/hosp/part-0.parquet
```
**as we can see here, it does**

**Now, we have to conjoin the necessary tables for the data**

**Since we have the dictionary for the diagnoses and the diagnoses themselves, we can merge them together to figure out what actually happened**

```{r}
LJDiagnoses <- diagnoses_icd.filter %>%
  left_join(d_icd_diagnoses.filter, by = c("icd_code", "icd_version"))

LJDiagnoses10 <- LJDiagnoses %>%
  head(10) %>%
  collect()

print(LJDiagnoses10)

```
**The top diagnoses were intestinal adhesions with obstruction, acurate respiratory failure with hypoxia, and von willebrand disease. We have to make sure we count each of the different long_titles and ensure they are able to put into the ggplot. I received an error regarding an as_vector, so let us set this to true to prevent this happening as well.**

```{r}
LJDiagnosesT3 <- LJDiagnoses %>%
  count(long_title, sort=TRUE) %>%
  head(3) %>%
  pull(long_title, as_vector = TRUE)
```

**Let us now left join the procedures based on the ICD_Code and ICD_version**

```{r}
LJProcedures <- procedures_icd.filter %>%
  left_join(d_icd_procedures, by = c("icd_code", "icd_version"))

LJProcedures10 <- LJProcedures %>%
  head(10) %>%
  collect()

print(LJProcedures10)

```

**I received an error prior about how this data is not a data.frame. Let us convert these to a data frame to prevent this from happening**

**Created data.frame so that we can use it in ggplot**
```{r}
transfer.filter2 <- as.data.frame(transfers.filter)
LJProcedures <- as.data.frame(LJProcedures)
```

**Changing it so that GGplot can read date and time better**
```{r}
transfer.filter2 <- transfer.filter2 %>%
  mutate(intime = as.POSIXct(intime, format="%Y-%m-%d %H:%M:%S"),
         outtime = as.POSIXct(outtime, format="%Y-%m-%d %H:%M:%S"))

LJProcedures <- LJProcedures %>%
  mutate(chartdate = as.POSIXct(chartdate, format="%Y-%m-%d"))

labevents.filter <- labevents_pq.filter %>%
  collect() %>%
  mutate(charttime = as.POSIXct(charttime, format="%Y-%m-%d %H:%M:%S"))
```

**We have to make sure we get the title of the graph as well**

**Let us get the patient's info**

```{r}
patient_info <- paste0(
  "Patient ", subject_id, ", ", 
  patients.filter$gender, ",", 
  patients.filter$anchor_age, " years old"
)

print(patient_info)
```

**When we do the regular ggplot, the legend has text that is way too long. Let us wrap this**

**Now let us make each procedure a unique factor so that it can be recognized in ggplot**

```{r}
library(stringr)

# Apply str_wrap() to wrap text for better legend display
LJProcedures$long_title_wrapped <- str_wrap(LJProcedures$long_title, 
                                            width = 17)

# Check result
print(LJProcedures)

```
**Now let us make each procedure a unique factor so that it can be recognized in ggplot**

```{r}
ProceduresUnique <- unique(LJProcedures$long_title_wrapped)
Shapemanual <- setNames(seq_along(ProceduresUnique) %% 
                          5 +20, ProceduresUnique)
Colormanual <- setNames(seq_along(transfer.filter2$careunit) %% 
                          25 +1, transfer.filter2$careunit)
```


**Now, let us make the ggplot**

```{r}
ggplot() +
 # Procedures (Different Shapes)
  geom_point(data = LJProcedures,  
             aes(x = chartdate, y = "Procedure", shape = 	
long_title_wrapped),  
             color = "black",   
             size = 4,  
             alpha = 0.7) +  
  
  # ADT Events (Colored by Care Unit)
  geom_segment(data = transfer.filter2, 
               aes(x = intime, xend = outtime, y = "ADT",  
                   color = careunit), 
               size = 4)  +

  # Lab Events (Black crosses `+`)
  geom_point(data = labevents.filter, 
             aes(x = charttime, y = "Lab"),
             shape = 3, size = 3, color = "black") +



  # Labels (Fixed title variable)
  labs(
    y = "", 
    x = "Calendar Time", 
    title = patient_info,  # Corrected variable usage
    subtitle = paste0("Top 3 Diagnoses:\n", 
                      paste(LJDiagnosesT3, collapse = "\n")),
    color = "Care Unit",
    shape = "Procedure"
  ) +  # Guides for Legend Formatting
guides(
    color = guide_legend(title = "Care Unit", nrow = 2, 
                         title.position = "top"),  
    shape = guide_legend(title = "Procedure", nrow = 1, 
                         title.position = "top"),
    override.aes = list(size=3))+
  
   # Care Unit Colors
 scale_color_manual(values = Colormanual) +
  # Procedure Shapes
  scale_shape_manual(values = Shapemanual) +
  scale_y_discrete(limits = rev) +

  # Theme Fixes to Ensure Plot is Visible
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.text.x = element_text(angle = 0, hjust = 1),
    legend.position = "bottom",  # Ensures legend is below
    legend.box = "vertical",  # Places legends in a single row
    legend.key.size = unit(1, "cm"),  # Adjusts legend item size
    legend.text = element_text(size = 7.5),
    plot.margin = margin(5, 5, 5, 5),
    legend.spacing.y = unit(0.01, "cm"),
    legend.box.spacing = unit(0.01, "cm")
  )
```


##1.2 Question 

**First, let us make sure that the chartevents.csv is read into the system and confirm that we have the right directory for it**

```{bash}

#| eval: false

zcat < ~/mimic/icu/chartevents.csv.gz > ~/mimic/icu/chartevents.csv

```

```{bash}

ls -l ~/mimic/icu/chartevents.csv
```

**We can now open the data set**

```{r}
chartevents.arrow <- arrow::open_dataset("~/mimic/icu/chartevents.csv", 
                                         format = "csv")
```

**And filter it based on the information we would like: 220045, 220181, 220179, 223761, and 22010**

```{r}
library(dplyr
        )
chartevents.filtered.arrow <- chartevents.arrow %>%
  dplyr::select(subject_id, itemid, charttime, valuenum) %>%
  dplyr::filter(itemid %in% c(220045, 220181, 220179, 223761, 220210)) %>%
  dplyr::filter(subject_id == !!subject_id)
  
```

**Let us make sure that everything looks correct**

```{r}
charteventsprint <- chartevents.filtered.arrow %>%
head(50) %>%
collect()

print(charteventsprint)
```

**Like before, we need to make sure that we make the data frame so that ggplot can read it and that the dates and time are consistent**

```{r}
chartevents.filtered.arrow <- as.data.frame(chartevents.filtered.arrow)
chartevents.filtered.arrow$charttime <- as.POSIXct(
  chartevents.filtered.arrow$charttime, format="%Y-%m-%d %H:%M:%S")
```

**Received an error saying that the values are not a factor. So let us make it one**

```{r}
chartevents.filtered.arrow$subject_id <- as.factor(
  chartevents.filtered.arrow$subject_id)
```

**Let us make sure that the above command worked**

```{r}
colnames(chartevents.filtered.arrow)
```

**Reading in the ICUStays and then filtering it for the ID given**

```{bash}

zcat < ~/mimic/icu/icustays.csv.gz > ~/mimic/icu/icustays.csv

```

```{r}

icustays <- arrow::open_dataset("~/mimic/icu/icustays.csv", format = "csv")

```

**I want to make sure that all the data sets are read in correctly after filtering**

**We can now do the same thing but this time filter the icustays with the correct subject_id**

```{r}
icustays.filtered <- icustays %>%
  collect() %>%
  dplyr::filter(subject_id == !!subject_id)
```

**Now we have to ensure that both of the factors are the same so that they can be graphed**

```{r}
icustays.filtered10 <- icustays.filtered %>%
  head(10) %>%
  collect()

print(icustays.filtered10)
```
```{r}

chartevents.filtered.arrow$subject_id <- as.integer(
  as.character(chartevents.filtered.arrow$subject_id))

icustays.filtered$subject_id <- as.integer(
  icustays.filtered$subject_id)

```

**To make it universal, we will have to figure out what the minimum and maximum charttimes are for both the stay_ids. We do the as.POSIXct as that is the error I got that I needed to fix**
```{r}
min_datetime1 <- as.POSIXct(icustays.filtered$intime[1])
max_datetime1 <- as.POSIXct(icustays.filtered$outtime[1])

min_datetime2 <- as.POSIXct(icustays.filtered$intime[2])
max_datetime2 <- as.POSIXct(icustays.filtered$outtime[2])

min_datetime1
max_datetime1 
min_datetime2
max_datetime2
```

**We are making it so that if the time falls between min and max 1, it is assigned the first stay_id. If it falls between min 2 and max 2, then it is assigned the second**

```{r}

chartevents.filtered.arrow <- chartevents.filtered.arrow %>%
  mutate(stay_id = case_when(
    charttime >= min_datetime1 & 
      charttime <= max_datetime1 ~ icustays.filtered$stay_id[1],
    charttime >= min_datetime2 & 
      charttime <= max_datetime2 ~ icustays.filtered$stay_id[2],
    TRUE ~ NA_real_  # Assign NA if charttime does not fit either stay
  ))

chartevents.filtered.arrow10 <- chartevents.filtered.arrow %>%
  head(10) %>%
  collect()

print(chartevents.filtered.arrow10)
```
```{r}
stay_ranges <- chartevents.filtered.arrow %>%
  group_by(stay_id) %>%
  summarise(min_time = min(charttime), max_time = max(charttime)) %>%
  ungroup()

# Use `scale_x_datetime()` but set the full range to include all timepoints
full_min_time <- min(stay_ranges$min_time)
full_max_time <- max(stay_ranges$max_time)
```

**With all the data in one table, we can not make the ggplot**

```{r}
ggplot(chartevents.filtered.arrow, 
       aes(x = charttime, y = valuenum, color = factor(itemid))) +
  geom_line(size = 0.8) + 
  geom_point(size = 1.5) + 
  facet_grid(itemid ~ stay_id, scales = "free_x", space = "free_x", 
             labeller = labeller(itemid = c(
    "220045" = "HR",
    "220179" = "NBPd",
    "220181" = "NBPs",
    "220210" = "RR",
    "223761" = "Temperature"
  ))) + 
  labs(
    title = paste("Patient", unique(chartevents.filtered.arrow$subject_id), 
                  "ICU stays - Vitals"),
    x = "",
    y = "",
    color = "Vital Type"
  ) +
  scale_x_datetime(date_labels = "%b %d %H:%M", date_breaks = "8 hours") +  
  theme_minimal() +
  theme(
    strip.text.x = element_text(size = 14, face = "bold", color = "white"),
    strip.text.y = element_text(size = 12, face = "bold"),
    strip.background = element_rect(fill = "grey50"),
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    legend.position = "none"
  )
```
